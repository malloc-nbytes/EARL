#+TITLE: EARL Lanugage Reference
#+DESCRIPTION: The "ins" and "outs" of EARL
#+AUTHOR: Zachary Haskins (malloc-nbytes)
#+EMAIL: zdhdev@yahoo.com
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+OPTIONS: num:nil






# ***************************************************************************** #
# IF YOU CAN SEE THIS TEXT, I SUGGEST OPENING UP THE .html VERSION OF THIS      #
# FILE THAT IS ALSO IN THE SAME DIRECTORY. IT HAS A MUCH MORE READABLE FORMAT.  #
# ***************************************************************************** #







_*NOTE for Grammar sections of this document*:_

#+begin_quote
- =This text format represents keywords=
- /This text format represents a type of grammar/
- <text> represents an identifier
- | represents OR
- [text] means list
- *(text) either 0 or more _of_
- ?(text) means 0 or 1 _of_
- "text" represents a string
#+end_quote

* Your First Program

To jump right into testing out EARL, do the following to implement a /Hello World!/ program.

Create a new file called =hello.earl=

#+begin_example
module Main

println("Hello World!");
#+end_example

Then run

#+begin_src bash
  earl ./hello.earl
#+end_src

Output:

#+begin_example
Hello World!
#+end_example

For more information on =module Main=, see [[Modules]].

* Typing

#+begin_quote
EARL is "gradually typed". This means that there are no explicit types, rather
the type of a variable is the type of the right hand side expression. Values are
also not dynamic, so once a variable has a type, it will always have that type. If
dynamic types are desired, see the =option= datatype in [[Datatypes][Datatypes]].

#+begin_example
let x = 1; # x is an int
let y = 1.2 # y is a float
let z = [1, 2, 3] # z is a list

x = "not allowed"; # results in an error because `x` is an integer.
#+end_example
#+end_quote

* REPL

** REPL Commands

#+begin_quote
If you were to just start =earl= without any files, it will
launch the built-in REPL. Here you can evaluate and run
code that is provided.

When in the REPL, typing =:= <cmd> will run a REPL command.
It will not evaluate any code, but you can use it to show the current session,
edit lines that have already been typed, remove lines, and more. Typing =$= <cmd> will issue
a shell command. To view more information, launch the REPL and type =:help=.
#+end_quote

** REPL Programming

#+begin_quote
If a line that is typed does not start with =:= or =$=, it will be
interpreted as code. Upon hitting =<enter>=, it will not immediately
evaluate the code. It only does code evaluation when an empty line is processed.
Because of this, you can code in _sessions_. Starting a new session does not mean
that the current environment is lost, but it essentially focuses on a new code block.
As long as =<enter>= has not been hit on an empty line, you can continue to write code
and have it wait to be evaluated. One benefit to this is that if a mistake has been made,
you can edit it or remove that line entirely by using the REPL command =:e= or =:rm=.
Keep in mind that as soon as =<enter>= is performed on an empty line, you will _not_ be
able to go back and change it as it starts a new session.

You will know when a new session starts because the line numbers on the left will reset to 0
and the last evaluated expression will have its result printed to stdout.

Using the REPL allows for one major benefit, which is immediate evaluation of _any_ expression.
This means that if =1 + 2;= is typed into the REPL followed by =<enter><enter>=, it will print
=3 -> int= (the value and the type). Here are some examples.

*Note*: The line numbers are provided from the REPL and you do not type these in.

*Note*: Some things will vanish while using the REPL to keep everything
clean looking, but I am unable to demonstrate it in text, so it will
be more verbose than it actually is i.e., (=[ENTER TO EVAL]=).

#+begin_example
0: let x = 1;
1: x;
2:                      [ENTER TO EVAL]
<unit> -> unit
1 -> int
0:
#+end_example

The first result =<unit> -> unit= is the result type of the =let= statement and can be ignored
as it's not important. The second output =1 -> int= is the result of =x;=.

Starting a new session does not remove variables that were created. That means that this is also valid:

#+begin_example
0: let x = 1;
1:                      [ENTER TO EVAL]
<unit> -> unit
0: x;
1:                      [ENTER TO EVAL]
1 -> int
0:
#+end_example

If you just want to do some quick math and use EARL as a calculator, here is another example:

#+begin_example
0: -(3 * (0.5 / float(2)) - 1);
1:                      [ENTER TO EVAL]
0.25 -> float
0:
#+end_example

It is important to note that if inside ={ }=, =[ ]=, and =( )=, the =<enter><enter>= will not
work. It will wait to evaluate the statements until you are outside of the nested brackets. This
means that if inside of a class, enum, function, or closure, you can hit =<enter>= as many times
as you want.

For example:

#+begin_example
0: fn fib(n) {
1:      if n < 2 {
2:              return n;
3:      }
4:
5:      return fib(n-1)+fib(n-2);
6: }
7: class Point [x, y] {
8:      @pub let x = x;
9:
10:     @pub let y = y;
11:
12:     @pub fn sumxy() {
13:         return this.x + this.y;
14:     }
15: }
16:                      [ENTER TO EVAL]
<unit> -> unit
<unit> -> unit
0: Point(fib(10), fib(15));
1:                      [ENTER TO EVAL]
<Class Point { y = 610, x = 55 }> -> class
0:
#+end_example

Another cool benefit of using the REPL is importing local files. By using the
REPL command =:i= <file1> <file2> ... <fileN>, it will essentially just insert the code in those
files in-place. After doing so, you can use and test functions, classes, enums etc. right from within
the REPL.

*Note*: You can also still use the =import= statement as well. See [[Imports][Imports]].

*Note*: The REPL uses some colors and if undesired can be disabled by using the =--repl-nocolor= flag.

*Note*: The REPL saves your history and stores it in =~/.earl_history= and will be cleared every time
it hits 1MB in file size.

*Note*: You can use left and right arrow keys to navigate back and forth in the text and the up and down arrows
to navigate through history. The stored history in =~/.earl_history= is what initializes this, so as soon
as you launch the REPL, it gives you the ability to hit the up arrow to get code from other sessions.

*Note*: Hitting =<tab>= will insert two spaces.

#+end_quote

* Keywords

#+begin_quote
|------------------------------------------------------------|
| let \rightarrow [[Variable Declarations]]                      |
| fn  \rightarrow [[Function Definitions]]                       |
| if \rightarrow [[Conditionals]]                                |
| else \rightarrow [[Conditionals]]                              |
| while \rightarrow [[While Loops]]                              |
| for \rightarrow [[For Loops]]                                  |
| foreach \rightarrow [[Foreach Loops]]                          |
| loop \rightarrow [[Forever Loops]]                             |
| in \rightarrow [[For Loops]], [[Foreach Loops]]                    |
| to \rightarrow [[For Loops]]                                   |
| break \rightarrow [[While Loops]], [[For Loops]], [[Foreach Loops]]    |
| continue \rightarrow [[While Loops]], [[For Loops]], [[Foreach Loops]] |
| import \rightarrow [[Imports]]                                 |
| almost \rightarrow [[Imports]]                                 |
| full \rightarrow [[Imports]]                                   |
| module \rightarrow [[Modules]]                                 |
| class \rightarrow [[Classes]]                                  |
| match \rightarrow [[Pattern Matching]]                         |
| when  \rightarrow [[Pattern Matching]]                         |
| enum \rightarrow [[Enumerations]]                              |
| @ref \rightarrow [[Attributes]]                                |
| @pub \rightarrow [[Attributes]]                                |
| @world \rightarrow [[Attributes]]                              |
| return                                                     |
| true                                                       |
| false                                                      |
| none                                                       |
#+end_quote

* Binary Operations

#+begin_quote
In the table below, the datatypes section describes which datatypes
are able to use the binary operations. This does not mean that if an
entry has (=int=, =list=), that you can add an integer to a list. Rather, it is
describing that the operator works for (=int= <op> =int=) or (=list= <op> =list=).

| Symbol | Datatypes                                                                          | Description                      |
|--------+------------------------------------------------------------------------------------+----------------------------------|
| +      | =int=, =float=, =list=, =str=                                                      | Adds the elements together       |
| -      | =int=, =float=                                                                     | Subtracts the elements           |
| *      | =int=, =float=                                                                     | Multiplies the elements together |
| ///    | =int=, =float=                                                                     | Divides the elements             |
| %      | =int=                                                                              | Produces the modulo              |
| **     | =int=, =float=                                                                     | Produces the power               |
| >      | =int=, =float=                                                                     | Greater than                     |
| <      | =int=, =float=                                                                     | Less than                        |
| >=     | =int=, =float=                                                                     | Greater than or equal to         |
| <=     | =int=, =float=                                                                     | Less than or equal to            |
| ==     | =bool=, =int=, =str=, =float=, =char=, =list=, =option=, =tuple=, =TypeKW=, =unit= | Equal to                         |
| !=     | =bool=, =int=, =str=, =float=, =char=, =list=, =option=, =tuple=, =TypeKW=, =unit= | Not equal to                     |
| &&     | =bool=, =option=                                                                   | Logical AND                      |
| <<     | =int=                                                                              | Bit shift left                   |
| >>     | =int=                                                                              | Bit shift right                  |
| `&     | =int=                                                                              | Bitwise AND (backtick needed)    |
| `~     | =int=                                                                              | Bitwise NOT (backtick needed)    |
| `^     | =int=                                                                              | Bitwise XOR (backtick needed)    |
=||=, =bool=, =option= \rightarrow Logical OR (this had to be separate to not misformat the table above)

=`|= Bitwise OR (backtick needed)
#+end_quote


* Variable Declarations

** Grammar

#+begin_quote
=let= <id> = /expr/;

or

=let= <id0>, <id1>, <id2>, ..., <idN> = /tuple/

where |tuple| $=$ number of ids.
#+end_quote

** Examples

#+begin_example
let k = 1;
let x = func(k);
let y = [1,2,3];
let z = (0..10).rev().filter(|x| { return x % 2 == 0; });

let a, b, c = (1, 2, 3);
let s = (1, 2);
let k, j = s;
#+end_example

* Mutation

#+begin_quote
Mutation describes changing a variables value in memory.
#+end_quote

** Grammar

#+begin_quote
/expr/ = /expr/;
#+end_quote

** Examples

#+begin_example
k = 1;
k = 3+9;
k = (3+3)*2;
lst[3] = 9+23;
lst[3].nth(1) = 9+23;
#+end_example

** Shorthand

#+begin_quote
For convenience, there are some shorthand operations that can be performed.

#+begin_example
k += N # substitutes -> k = k + (N);
k -= N # substitutes -> k = k - (N);
k *= N # substitutes -> k = k * (N);
k /= N # substitutes -> k = k / (N);
k %= N # substitutes -> k = k % (N);
k `|= N # substitutes -> k = k `| (N);
k `&= N # substitutes -> k = k `& (N);
k `^= N # substitutes -> k = k `^ (N);
#+end_example
#+end_quote

* Conditionals

#+begin_quote
Conditionals are =if=, =if-else=, and =if-else-if= statements.
If the expression is true, that branch will occur.
#+end_quote

** Grammar

#+begin_quote
=if= /expr/ *{* [stmt] *}*

=else if= /expr/ *{* [stmt] *}*

=else= *{* [stmt] *}*
#+end_quote

** Examples

#+begin_example
if k == 2 {
    # code
}
else if (k+1 == 9) {
    # code
}
else {
    # code
}
#+end_example

* Pattern Matching

#+begin_quote
*Note*: Pattern matching is still a work in progress and may be buggy.

*Note*: Pattern matching on lists is not yet fully implemented.

Pattern matching allows you to match on some pattern. This is
the case for all primitives =int=, =str=, =list= etc.

A =match= consists of a two things.
1. The pattern \rightarrow this comes right after the =match= keyword
2. Branches \rightarrow these are all the different patterns can be

Each branch can either specify one pattern or multiple patterns with the =|= (or) operator.
The =when= keyword acts as a /guard/ for the branch. If the pattern matches, only then is the
/guard/ evaluated. If the /guard/ is true, only then will the branch activate.

And finally, the base case consists of the pattern =_=. If none of the other branches *above* this
one happens, this one is guaranteed to happen (unless there is a guard).
#+end_quote

Grammar TODO

** Examples

#+begin_example
let x = 4;
let msg = "foo";

match x {
    1 -> { println("x is 1"); }
    2 | 3 -> { println("x is two or three"); }
    [1,2,3] when type(x) == "list" -> { println(x is a list and is [1,2,3]"); }
    4 when msg = "bar" -> { println("x is 4 with msg = bar"); }
    4 when msg = "foo" -> { println("x is 4 with msg = foo"); }
    _ when msg = "hello" -> { println("base case, 4 is something else and msg = hello"); }
    _ -> { println("base case, 4 is something else"); }
}
#+end_example

Output:

#+begin_example
x is 4 with msg = foo
#+end_example

#+begin_example
let x = some(4);

match x {
    none -> {
        print("x is none");
    }
    some(3) -> {
        print("x is some 3");
    }
    some(k) when k % 2 == 1 -> {
        print("x is something and is odd");
    }
    some(k) -> {
        # This branch will execute.
        # `k` is the unwrapped value of `x`.
        print("x is: ", k);
        print(x.unwrap() == k);
    }
    some(_) -> {
        print("x is something");
    }
    _ -> {
        print("x is something else");
    }
}
#+end_example

Output:

#+begin_example
x is: 4
true
#+end_example

#+begin_quote
*Note*: For more information on =some= and =none=, see =option= in [[Datatypes]].
For =unwrap()=, see =unwrap= in [[Member Intrinsics]].
#+end_quote

* While Loops

#+begin_quote
=while= loops will continue to loop while the expression is =true=.
#+end_quote

** Grammar

#+begin_quote
=while= /expr/ *{* [stmt] *}*
#+end_quote

** Examples

#+begin_example
let i = 0;
while i < 3 {
    print(i);
    i += 1;
} # prints 012
#+end_example

* For Loops

#+begin_quote
For loops will enumerate over a range of numbers, with the enumerator being assigned the current number.
If the enumerator is less than the initial destination value, it will be incremented. If it is less than the
initial destination value, it will decrement.

*Note*: There is a special extra step that is taken if enumerating down. Let $i$ be the enumerator and $e$ be the
end where $i >= e$. The loop will stop when $i < e$. This makes it so that if enumerating from =10 to 0=, it will stop
at $-1$. This is not the case if we are enumerating upwards.
#+end_quote

** Grammar

#+begin_quote
=for= <id> =in= /expr/ =to= /expr/ *{* [stmt] *}*
#+end_quote

** Examples

#+begin_example
for i in 0 to 5 {
    print(i);
} # prints 01234

for i in 5 to 0 {
    print(i);
} # prints 543210

let lst = [1,2,3];
for i in 0 to len(lst) {
    print(lst[i]);
} # prints 123

for i in len(lst)-1 to 0 {
    print(lst[i]);
} # prints 321
#+end_example

* Foreach Loops

#+begin_quote
Foreach loops take a list, string, or tuple and will iterate over the elements.
The most common way to use these loops is with a =range= (see [[Ranges][Ranges]]). Also, the iterator
(usually the variable labeled as $i$), can be set as a reference (see [[Attributes]]) to the expression.
This means that $i$ will be take the reference of each iterated value in the list and can modify it directly
(see /ref example/ below).
#+end_quote

** Grammar

#+begin_quote
=foreach= * (=@= =ref= | =const=) <id> =in= /expr/ *{* [stmt] *}*
#+end_quote

** Examples

#+begin_example
foreach i in 0..5 {
    print(i);
} # prints 12345

let iterable = [9,4,2];
foreach i in iterable {
    print(i);
} # prints 942

foreach i in (0..5).rev() {
    print(i);
} # prints 43210

foreach i in 0..len(iterable) {
    print(i);
} # prints 012

foreach @ref i in iterable { # REF EXAMPLE
    i = 9;
}
println(iterable); # prints [9, 9, 9]

foreach @const @ref i in "foo" {
    print(i);
} # prints foo

foreach i in 'a'..'d' {
    print(i);
} # prints abc

let s = "bar";
foreach i in s {
    print(i);
} # prints bar
#+end_example

* Forever Loops

#+begin_quote
The point of Forever loops is in their name, they will loop forever until
manually breaking out of them.
#+end_quote

** Grammar

#+begin_quote
=loop= *{* [stmt] *}*
#+end_quote

** Examples

#+begin_example
loop {
    println("foo");
} # will never end

let i = 0;
loop {
    if i == 5 { break; }
}

loop {
    if i == 10 { return; }
}
#+end_example

* Function Definitions

#+begin_quote
This is how to create a function. The =@world=, =@pub= and =@ref= are attributes. See [[Attributes]] for a description on them.
#+end_quote

** Grammar

#+begin_quote
*( =@= [ =pub= | =world= ])

=fn= <id> *(* [ * ( =@ref= | =@const= ) <id> ] *)* *{* [stmt] *}*
#+end_quote

** Examples

#+begin_example
@world @pub
fn func1(@ref x, y, @ref @const z) {
    ...
}

fn func2() {
    ...
}
#+end_example

* Imports

#+begin_quote
EARL looks for the files relative to the directory
that it was invoked in. During runtime, if an =import=
statement is hit, it will immediately interpret that file.
If there is no processing in the =@world= scope, only the
function definitions and classes are gathered.

If importing something from the stdlib, you want to start the import
string with "std/" then the file name. It will look at the prefix that
the project was compiled with that CMake set up (=-DINSTALL_PREFIX=) and append "EARL/" to it.
If you did not do this, or this section does not make any sense, then the stdlib is most likely installed
in =/usr/local/=. tl;dr make sure to put "std/" before the filename if using the stdlib.

When importing, a depth can be specified. Use =full=
if you want all public elements from the file (enums, functions, variables, classes, etc.),
or =almost= if you only desire public variables and enums. If none is provided, =full= will be used by default.
#+end_quote

** Grammar

#+begin_quote
=import= "filepath" ?(=full= | =almost=)
#+end_quote

** Examples

#+begin_example
# stdlib imports
import "std/list.earl" full
import "std/math.earl" # uses `full`
import "std/utils.earl" almost

# local imports
import "my-local-file.earl" almost
#+end_example

* Modules

#+begin_quote
/Modules/ allow other files to access resources to the
file that has the module declared in it. If a file does
not have it, the entire file is private. While modules
do allow other files to access resources, only resources
that have the =@pub= attribute (see [[Attributes]]).

To access some identifer from a different module, you use =::= syntax
(similar to C++ namespaces).

*It is expected to have the module declaration at the top of the file.
If you do not follow this rule, undefined behavior can occur.* If you
forget, the interpreter will throw a warning (with the exception of using the REPL
as the REPL module is not required).
#+end_quote

** Grammar

#+begin_quote
=module= <id>
#+end_quote

** Examples

#+begin_example
.
├── main.earl
└── my-math.earl

1 directory, 2 files
#+end_example

#+begin_quote
file: =my-math.earl=
#+begin_example
module MyMath

# Function is marked as @pub to make it
# accessible to other modules.
@pub fn sum(a, b) {
    return a+b;
}
#+end_example

file: =main.earl=
#+begin_example
module Main

import "my-math.earl"

let s = MyMath::sum(1, 2);
#+end_example
#+end_quote

* Attributes

#+begin_quote
Attributes embeds meta information into identifiers. You can have none, one, or multiple.

| Name     | Variables | Functions | Classes       | Enumerations  | Description                                                  |
|----------+-----------+-----------+---------------+---------------+--------------------------------------------------------------|
| =@pub=   | YES       | YES       | YES           | YES           | Makes the identifier available to other files                |
| =@world= | NO        | YES       | UNIMPLEMENTED | UNIMPLEMENTED | The identifier closes in the world scope                     |
| =@ref=   | YES       | NO ***    | NO            | NO            | Declares the variable to be a reference (see the note below) |
| =@const= | YES       | NO        | NO            | NO            | Declares the variable as constant                            |

*NOTE:* =@ref= can be used in a function parameter and that function will
take a reference to the value passed to it.
#+end_quote

** Grammar

#+begin_quote
=@= *(pub | world | ref | const)
#+end_quote

** Examples

#+begin_example
@world @pub
fn test_world() {
    # `i` will print since it is in the world scope.
    # The function is also marked as public so other
    # modules can have access to this function.
    print(i)
}

@pub fn take_ref(@ref ptr) {
    ptr = ptr + 1;
}

let i = 1;
test_world();

@ref let ptr = i;
ptr = ptr + 1;

assert(ptr == 2 && i == 2);

take_ref(i);

assert(i == 3);

#+end_example

* Enumerations

#+begin_quote
Enumerations (/enums/) act as it's own datatype, but they are just integers.
They compose of comma separated identifiers and each identifier can optionally
have an assignment to it. By default, if no assignments are made, it starts
at 0 and increments by 1 for each enum item. Once an assignment is found,
it will start incrementing from _that number_.

To access an enum element, use the dot `.` notation i.e, =MyEnum.Element1= and
can be accessed from other modules using the double colon `::` notation (as long as
it has the =@pub= attribute).

An /enum/ can consist of multiple datatypes, however, once a datatype other than
an integer is encountered, all values of the entries in the /enum/ _must_ be specified.
#+end_quote

** TODO Grammar

** Examples

#+begin_example
import "external-enum.earl" almost

@pub enum MyPubEnum {
    El1,     # contains 0
    El2 = 2, # contains 2
    El3,     # contains 3
    El4 = 9, # contains 9
    El5,     # contains 10
    El6,     # contains 11
}

let my_enum_el = MyPubEnum.El2;
println(my_enum_el, ' ', MyPubEnum.El5); # prints `2 10`
println(ExternalEnum::MyEnum.Item3); # prints the enum element from "external-enum.earl"
#+end_example

#+begin_example
let x = [1,2,3];

# All values are must be explicit if datatypes other
# than integers are used.
enum MixedEnum {
    El1 = 0,
    El2 = "hello",
    El3 = some(some('a')),
    El4 = x
}
#+end_example

* Classes

#+begin_quote
While classes are available, support for inheritance is not yet implemented.
1. All member variable assignments will happen. If the class has bracket notation =[ ... ]=,
   it will use these.
2. If there is a function called =constructor= in the class, that function will immediately happen.
3. For visibility:
   - All member variables that have the =@pub= attribute will be visible outside of the class scope, including other modules (if the class is marked as =@pub=).
   - All methods that have the =@pub= attribute will be visible outside of the class scope, including other modules (if the class is marked as =@pub=).
   - Everything that does not have =@pub= will only be visibile to the class scope.
4. The use of the =this= keyword is optional.

To use _public_ member variables or _public_ methods from outside of the class scope, you use the
dot `.` notation, i.e., =MyClass.member_var= or =MyClass.my_method()=.
#+end_quote

** Grammar

#+begin_quote
*( =@= pub | world | ref)

=class= <id> =[= *(<arg>) =]= ={=

    *(<let stmt>)

    ?(fn constructor() {})

    *(<function definitions>)

=}=
#+end_quote

** Examples

#+begin_example
# This class takes no arguments for the
# constructors and is also not public,
# so other modules cannot use this class.

class NoPassesArgs [] {
    let x = 1;
    let y = 2;

    @pub fn print() {
        # The use of `this` keyword is optional.
        # Because this function is marked as @pub,
        # it is visible to the outside.
        print(this.x, y);
    }
}
#+end_example

#+begin_example
# This class is marked as @pub, so it is
# visible to other modules.
@pub class Point [x, y, name] {
    # Because this is public, you can access
    # it directly from outside the class.
    @pub let x, y = (x, y);
    @pub let desc = "A point class"

    let name = name;

    # Function not marked as @pub so
    # it does is not visible outside
    # of this class.
    fn helper() {
        println("in helper");
    }

    @pub fn set_x(newx) {
        this.x = newx
    }

    @pub fn show() {
        print(this.x);
        print(this.y);
        print(this.name);
        print(this.desc);
    }
}
#+end_example

#+begin_example
@pub class Stack [init] {

    ### THIS HAPPENS FIRST ######
    # You could just assign `init` to `lst` here,
    # but for this example, this is done in the constructor.
    let lst = [];
    let sz = 0;
    ############################


    ### THIS HAPPENS SECOND #######
    # The constructor gets called
    # right after class instantiation.
    fn constructor() {
        for i in 0..len(init) {
            this.push(init[i]);
        }
    }
    ###############################

    @pub fn push(x) {
        this.lst.append(x);
        this.sz = this.sz+1;
    }

    @pub fn pop() {
        this.lst.pop(this.sz-1);
        this.sz = this.sz-1;
    }
}
#+end_example

* Datatypes

#+begin_quote
The following is a list of the currently implemented primitive types.
#+end_quote

** =int=

#+begin_quote
Your basic 32 bit integer datatype.

*Note*: They *do* over/under-flow
#+end_quote

** =float=

#+begin_quote
Your basic 64 bit floating pointer number.

*Note*: They *do* over/under-flow
#+end_quote

** =bool=

#+begin_quote
The boolean datatype. Can either be =true= or =false=.
#+end_quote

** =char=

#+begin_quote
A single character. They are surrounded by single quotes ='=.
#+end_quote

** =str=

#+begin_quote
A string is a list of =char='s. They are surrounded with double quotes ="=.
#+end_quote

*** fstr

#+begin_quote
=fstr= is syntax sugar to put variables inside of a string literal.
They start with =f= followed by a string literal. All identifiers enclosed
with ={ }= will have their value stringified.

*Note*: They currently only work with *identifiers*.

#+begin_example
let x = [1, 2, 3];
let y = 3;
let s = f"x is {x} and y is {y}";
println(s); # prints "x is [1, 2, 3] and y is 3"
#+end_example
#+end_quote

** =list=

#+begin_quote
A list is a growable array. They can hold any datatype, and you
can even mix multiple datatypes in a single list. They can be initialized with
braces or a =range=.

#+begin_example
let lst0 = [];
let lst1 = [1,2,3];
println(lst0); # prints []
println(lst1); # prints [1, 2, 3]

let lst2 = 1..3;
let lst3 = (1..3).rev();
let lst4 = 'a'..='c';
println(lst2); # prints [1, 2];
println(lst3); # prints [2, 1];
println(lst4); # prints ['a', 'b', 'c'];
#+end_example
#+end_quote

*** Ranges

#+begin_quote
Ranges are not their own datatype, they are just syntax sugar for a list. For example:

#+begin_example
1..5 # expands to [1, 2, 3, 4]
1..=5 # expands to [1, 2, 3, 4, 5]
'a'..'d' # expands to ['a', 'b', 'c'];
'a'..='d' # expands to ['a', 'b', 'c', 'd'];
(1..=10).rev().filter(|x| { x%2 == 0; }); # expands to [10, 8, 6, 4, 2]
#+end_example

Currently they only work with =int= and =char=.
#+end_quote

** =Slice=

#+begin_quote
Currently, =slice= types are only useful for indexing a =list=. They allow you to
take a slice of the list and create a new list of those elements. They are two expressions
separated by a colon =:=.

A =slice= is defined by:

# Let $S$ be a "starting" expression, $E$ be an "ending" expression, and L be some nonempty list of elements
# and $S \le E$ in

Given a "starting" and "ending" expression $S, E \in \mathbb{Z} \text{ where } S \le E$ and some nonempty list of elements $L$ then

$L_{S : E} = [L_{S}, L_{S+1}, L_{S+2}, ..., L_{E-1}]$

and

- If $S$ is either empty or =unit=, then $S = 0$.
- If $E$ is either empty or =unit=, then $E = |L|$.
- If both $S$ and $E$ are either empty or =unit=, then $L_{S : E} = L$.

#+begin_example
let lst = [1,2,3,4,5];
println(lst[0:3]); # prints [1, 2, 3]
println(lst[:4]);  # prints [1, 2, 3, 4]
println(lst[_:4]); # prints [1, 2, 3, 4]
println(lst[0:0])  # prints []
println(lst[3:]);  # prints [4, 5]
println(lst[3:_]); # prints [4, 5]
println(lst[:]);   # prints [1, 2, 3, 4, 5]
println(lst[_:_]); # prints [1, 2, 3, 4, 5]

let sl = 1:3;
println(lst[sl])   # prints [2,3]
#+end_example
#+end_quote

** =tuple=

#+begin_quote
A =tuple= is the exact same thing as a =list= except they are /immutable/.
You cannot reassign, append, or modify a =tuple=. You can use bracket notation
=[]= to index values.

They can be created by using parenthesis and having elements be separated by commas _(including tuples of size 1)_:

#+begin_example
let tuple = (1, 'a', [1,2,3]);
tuple.foreach(|x| { println(x); });

let single_elem_tuple = (1,); # note the comma here
println(single_elem_tuple[0]);
#+end_example

*Note*: If an empty =tuple= is desired (why would you ever want this?) you can use the intrinsic casting
function =tuple()= i.e., =let empty_tuple = tuple()=.
#+end_quote

** =option=

#+begin_quote
Because all variables need to be initialized when using a `let` statement,
it may be annoying to be forced to give it some initial value. The =none= type
allows you to set a variable to it and can be reassigned later.

To assign a value to a none-type, you must wrap it in =some= i.e.,

#+begin_example
let x = none;
x = some(9);
#+end_example

The underlying value (in the above example, =9=) can be extracted out
using the =unwrap()= member intrinsic.

Another important note is that the underlying value that the =option= holds is dynamic:

#+begin_example
let x = some(8);
println(x.unwrap()); # prints 8
x = some('a');
println(x.unwrap()); # prints 'a'
#+end_example
#+end_quote

** =closure=

#+begin_quote
Closures are anonymous functions that close in the outer scope. They
can be used as functions or passed around as variables. The closure parameters
are surrouned by vertical bars =||=. If a closure does not take any parameters,
then the item inside of the vertical bars is =_= i.e., =|_|=.

Here is an example of c++ lambdas and the equivalent EARL closures.

#+begin_example
std::function<int(int, int)> sum_and_modify_b = [&](int a, int &b) -> int {
    std::cout << "in sum" << std::endl;
    b *= 2;
    return a+b;
}

std::function<int(void)> loop = [](void) -> void {
    for (int i = 0; i < 10; ++i)
        std::cout << i << std::endl;
}

std::vector<int> v = {1,2,3,4,5};
v.for_each(v.begin(), v.end(), [](int k) { std::cout << k << std::endl; });
#+end_example

#+begin_example
let sum_and_modify_b = |a, @ref b| {
    println("in sum");
    b *= 2;
    return a+b;
}

let loop = |_| {
    foreach i in 0..10 {
        println(i);
    }
}

let v = [1,2,3,4,5];
v.foreach(|k| { println(k); });
#+end_example

Some other examples:

#+begin_example
fn take_sum_closure(f, a, b) {
    f(a, b);
}

let msg = "hello world";
let hello = |_| {
    print(msg);
};

let sum = |a, b| {
    print("in sum");
    return a+b;
};

hello();

print(take_sum_closure(sum, 1, 2));
#+end_example

Output:
#+begin_example
hello world
in sum
3
#+end_example

#+end_quote

** =dictionary=

#+begin_quote
A =dictionary= is a collection of key-value pairs. Every key has an associated value.
If a dictionary is indexed with a key that does not exist, it will return a =none= value.
If the value _does_ exist, it will return it in a wrapped =some= value.
They can be created with a brace initializer list where keys and values are separed by a colon =:=
and entries are separated by a comma =,=.

The keys in dictionaries must be uniform throughout, although the values can be of any type.
They must also be initalized with data so it can infer the type of the keys, however you may want
an empty set. This can be done by using the =Dict(type: TypeKW) -> Dict<type>= function which will
produce an empty dictionary that holds keys of type =type=.

#+begin_example
let empty_set = Dict(int);

# Notice how all keys are strings
let s = {"foo": 1, "bar", 1..=10, "baz": some('a')};

println(s["foo"]);         # some(1)
println(s["bar"].unwrap()) # [1,2,3,4,5,6,7,8,9,10]
println(s["baz"].unwrap().unwrap()) # 'a'
println(s["invalid"]);     # none

s.insert("hello", 9);
println(s.has_key("hello") && s.has_key("bar")); # true
println(s.has_value(1))        # true

println(empty_set.has_key(3)); # false
empty_set.insert(3, [1,2,3]);
println(empty_set.has_key(3)); # true
println(empty_set[3]); # [1,2,3]
#+end_example
#+end_quote

** =TypeKW=

#+begin_quote
=TypeKW= (or Type Keyword) are global identifiers for types. You are unable to do
any operations on them except for passing them around as variables, using them as
raw values, or doing equality ==== or =!==.

*Note*: These are not the same as the casting functions.

#+begin_example
let integer_type = int;
let str_type = str;
println(integer_type == str_type); # false
#+end_example
#+end_quote

** =file=

#+begin_quote
The =file= type is a file handler. It handles opening, closing, reading, and writing
to files. The way to get a file handler is by using the intrinsic function =open()= (see [[Intrinsics]]).

*Note*: It is up to the user to =close()= the file handle.
#+end_quote

** =unit=

#+begin_quote
The =unit= type is used as a "throwaway". It essentially throws
away the value that gets assigned to it. The following are all
examples of correct usage of it:

=let _ = print("hello");=

=let _ = 1;=

=let cl = |_| { print("hello"); };=

=match x { _ -> { print("example"); } }=
#+end_quote

* Intrinsics

#+begin_quote
Intrinsics are functions that are automatically built into the interpreter.
You do not need to import anything to use these functions.
#+end_quote

** =print=

#+begin_quote
#+begin_example
print(arg1: any, arg2: any, ..., argN: any) -> unit
#+end_example

Will print all elements if it can.
#+end_quote

** =println=

#+begin_quote
#+begin_example
println(arg1: any, arg2: any, ..., argN: any) -> unit
#+end_example

Will print all elements if it can. Adds a newline at the end.

*Note*: If given a class or enum, both this function and =print()= will
do an in-depth print showing all variables that they contain as well
as their value. This is very helpful for debugging.
#+end_quote

** TODO =fprint=

#+begin_quote
#+begin_example
fprint(fd: int|file, arg1: any, arg2: any, ..., argN: any) -> unit
#+end_example

Will print all elements to the file descriptor =fd=.
#+end_quote

** TODO =fprintln=

#+begin_quote
#+begin_example
fprintln(fd: int|file, arg1: any, arg2: any, ..., argN: any) -> unit
#+end_example

Will print all elements as well as a newline to the file descriptor =fd=.
#+end_quote

** =input=

#+begin_quote
#+begin_example
input(arg1: any, arg2: any, ..., argN: any) -> str
#+end_example

Will print all elements if it can. Gets input from the user
and returns it as a =str=.
#+end_quote

** =int=

#+begin_quote
#+begin_example
int(arg: int|float|str|bool) -> int
#+end_example

Casts =arg= to an =int=.
#+end_quote

** =float=

#+begin_quote
#+begin_example
float(arg: int|float|str) -> float
#+end_example

Casts =arg= to a =float=.
#+end_quote

** =str=

#+begin_quote
#+begin_example
str(arg: int|float|str|bool|option) -> str
#+end_example

Casts =arg= to a =str=.
#+end_quote

** =bool=

#+begin_quote
#+begin_example
bool(arg: int|float|str) -> bool
#+end_example

Casts =arg= to a =bool=.
#+end_quote

** =tuple=

#+begin_quote
#+begin_example
tuple(arg0: any, arg1: any, ..., argN: any) -> tuple
#+end_example

Cast the values to a =tuple=. You can also supply 0 arguments to create an empty =tuple=.
#+end_quote

** =list=

#+begin_quote
#+begin_example
list(arg0: any, arg1: any, ..., argN: any) -> list
#+end_example

Cast the values to a =list=. You can also supply 0 arguments to create an empty =list=.
#+end_quote

** =Dict=

#+begin_quote
#+begin_example
Dict(ty: TypeKW) -> Dict<ty>
#+end_example

Creates a new *empty* dictionary that holds keys of type =ty=.
#+end_quote

** =assert=

#+begin_quote
#+begin_example
assert(arg1: bool, arg2: bool, ..., argN: bool) -> unit
#+end_example

Tests each argument. If any of the conditions fail,
the program immediately crashes.
#+end_quote

** =len=

#+begin_quote
#+begin_example
len(arg: list|str|tuple) -> int
#+end_example

Expects either a =list=, =string=, or =tuple=. Will give the length
as an integer.
#+end_quote

** =some=

#+begin_quote
#+begin_example
some(arg: any) -> option<any>
#+end_example

Wraps =arg= in an =option= type.
#+end_quote

** =type=

#+begin_quote
#+begin_example
type(arg: any) -> str
#+end_example

Returns the type of =arg= as a =str=.
#+end_quote

** =typeof=

#+begin_quote
#+begin_example
typeof(arg: any) -> TypeKW
#+end_example

Returns the type of =arg= as a =TypeKW=.
#+end_quote

** =argv=

#+begin_quote
#+begin_example
argv() -> list
#+end_example

Returns a list of =str= of the supplied command line arguments
that were given by the =--= option.
#+end_quote

** =open=

#+begin_quote
#+begin_example
open(fp: str, mode: str) -> file
#+end_example

Opens the filepath =fp= with mode =mode=. Mode must either be
=r= for read, =w= for write, or =b= for binary. You can also
supply multiple modes by combining the letters into a single =str=
i.e., ="wrb"=.
#+end_quote

** =unimplemented=

#+begin_quote
#+begin_example
unimplemented(arg1, arg2, ..., argN)
#+end_example

Prints "UNIMPLEMENTED" arg1..arg$N$ to =stderr= and exits with non-zero exit code.
#+end_quote

* Member Intrinsics

#+begin_quote
Member intrinsics are the same as intrinsics, except they are
member functions (or methods) that types have built into them.
You access these with the dot `.` notation i.e.,

#+begin_example
let lst = [1,2,3];
lst = lst.rev();
#+end_example
#+end_quote

** =list= Implements

#+begin_quote
#+begin_example
append(arg1: any, arg2: any, ..., argN: any) -> unit
#+end_example

Will append arg1..arg$N$ to the list.
#+end_quote

#+begin_quote
#+begin_example
pop(idx: int) -> unit
#+end_example

Will remove the element at index =idx=.
#+end_quote

#+begin_quote
#+begin_example
rev() -> list
#+end_example

Returns a new list that is the reverse of the original.
#+end_quote

#+begin_quote
#+begin_example
filter(cl: closure) -> list
#+end_example

Takes the closure =cl= and creates a new =list= of all the
elements where =cl= returns =true=.
#+end_quote

#+begin_quote
#+begin_example
foreach(cl: closure) -> unit
#+end_example

Calls the closure =cl= on each element.
#+end_quote

#+begin_quote
#+begin_example
map(cl: closure) -> list
#+end_example

Calls the closure =cl= on each element and creates a new list on the evaluated results.
#+end_quote

#+begin_quote
#+begin_example
contains(val: any) -> bool
#+end_example

Checks to see if =val= is in the =list=.
#+end_quote

** =str= Implements

#+begin_quote
#+begin_example
append(arg1: char|str, arg2: char|str, ..., argN: char|str) -> unit
#+end_example

Will append arg1..arg$N$ to the =str=.
#+end_quote

#+begin_quote
#+begin_example
pop(idx: int) -> unit
#+end_example

Will remove the element at index =idx=.
#+end_quote

#+begin_quote
#+begin_example
rev() -> str
#+end_example

Returns a new =str= that is the reverse of the original.
#+end_quote

#+begin_quote
#+begin_example
filter(cl: closure) -> str
#+end_example

Takes the closure =cl= and creates a new =str= of all the
elements where =cl= returns =true=.
#+end_quote

#+begin_quote
#+begin_example
foreach(cl: closure) -> unit
#+end_example

Calls the closure =cl= on each element.
#+end_quote

#+begin_quote
#+begin_example
split(delim: str) -> list
#+end_example

Split a string by the delimiter =delim=.
#+end_quote

#+begin_quote
#+begin_example
contains(ch: c) -> bool
#+end_example

Checks to see if =val= is in the =str=.
#+end_quote

** =dictionary= Implements

#+begin_quote
#+begin_example
insert(k: any, v: any) -> unit
#+end_example

Inserts the key =k= and value =v= into the dictionary.
#+end_quote

#+begin_quote
#+begin_example
has_key(k: any) -> bool
#+end_example

Returns =true= if the key =k= is present in the dictionary and false if otherwise.
#+end_quote

#+begin_quote
#+begin_example
has_value(v: any) -> bool
#+end_example

Returns =true= if the value =v= is present in the dictionary and false if otherwise.
#+end_quote

** =tuple= Implements

#+begin_quote
#+begin_example
rev() -> tuple
#+end_example

Returns a new tuple that is the reverse of the original.
#+end_quote

#+begin_quote
#+begin_example
filter(cl: closure) -> tuple
#+end_example

Takes the closure =cl= and creates a new =tuple= of all the
elements where =cl= returns =true=.
#+end_quote

#+begin_quote
#+begin_example
foreach(cl: closure) -> unit
#+end_example

Calls the closure =cl= on each element.
#+end_quote

#+begin_quote
#+begin_example
contains(val: any) -> bool
#+end_example

Checks to see if =val= is in the =tuple=.
#+end_quote

** =char= Implements

#+begin_quote
#+begin_example
ascii() -> int
#+end_example

Returns the ascii code of the character.
#+end_quote

** =option= Implements

#+begin_quote
#+begin_example
is_none() -> bool
#+end_example

Returns =true= if the value is =none=, =false= otherwise.
#+end_quote

#+begin_quote
#+begin_example
is_some() -> bool
#+end_example

Returns =true= if the value is =some=, =false= otherwise.
#+end_quote

#+begin_quote
#+begin_example
unwrap() -> any
#+end_example

Returns the inner value of the =option= datatype. If the =option= is
=none=, a panic will occur.
#+end_quote

** =file= Implements

#+begin_quote
#+begin_example
close() -> unit
#+end_example

Closes an opened file.
#+end_quote

#+begin_quote
#+begin_example
read() -> str
#+end_example

Get the contents of a file as a =str=.
#+end_quote

#+begin_quote
#+begin_example
dump() -> unit
#+end_example

Print the contents of a file.
#+end_quote

#+begin_quote
#+begin_example
write(msg: str|char|int) -> unit
#+end_example

Writes =msg= to the opened file.
#+end_quote

#+begin_quote
#+begin_example
writelines(msg: list) -> unit
#+end_example

Writes all elements in the list =msg= to the opened file.
At the end of each value, a newline is added.
#+end_quote

* StdLib

#+begin_quote
Upon installing EARL, the standard library is installed into
=-DINSTALL_PREFIX= (=/usr/local/include/= by default). The first place that EARL looks
when evaluating an =import= statement is =-DINSTALL_PREFIX=.
This means that all you need to do to import these files is do:
=import "std/<file>.earl"= <depth>.
#+end_quote

*Note*: The following is generated from =stdlib-docs-gen.earl= so it should
never be modified by hand.

# ********** DO NOT MODIFY BELOW THIS LINE AS IT IS AUTOGENERATED BY stdlib-docs-gen.earl **********

# BEGIN_AUTOGEN
** Math

*** *Import*: ="std/math.earl"=

*** *Module*: =Math=

*** *Variable List*:
#+begin_quote
#+begin_example
PI: float
#+end_example

The mathematical constant for pi.
#+end_quote

#+begin_quote
#+begin_example
EULER: float
#+end_example

The mathematical constant for Euler's number
#+end_quote

*** *Enum List*: /None/

*** *Function List*:
#+begin_quote
#+begin_example
max(x: int|float, y: int|float) -> int|float
#+end_example

Returns the greater of =x= and =y=.
#+end_quote

#+begin_quote
#+begin_example
max(x: int|float, y: int|float) -> int|float
#+end_example

Returns the minimum of =x= and =y=.
#+end_quote

#+begin_quote
#+begin_example
max(x: int|float) -> int|float
#+end_example

Returns the absolute value of =x=.
#+end_quote

#+begin_quote
#+begin_example
mode(lst: list) -> list
#+end_example

This function returns a list of all modes that appear at the highest frequency in the given list in the order modes are found.
#+end_quote

#+begin_quote
#+begin_example
mean(lst: list) -> float
#+end_example

Returns the mean (average in a dataset) of a given list.
#+end_quote

#+begin_quote
#+begin_example
median(lst: list) -> int
#+end_example

This function sorts and then returns the middle number of a given list
#+end_quote

#+begin_quote
#+begin_example
list_min(lst: list) -> int|float
#+end_example

Returns the smallest element =lst=.
#+end_quote

#+begin_quote
#+begin_example
list_max(lst: list) -> int|float
#+end_example

Returns the largest element =lst=.
#+end_quote

#+begin_quote
#+begin_example
area_of_circle(r: float|int) -> float|int
#+end_example

Returns the area of a circle with radius =r=.
#+end_quote

#+begin_quote
#+begin_example
area_of_cylinder(r: float|int, h: float|int) -> float|int
#+end_example

Returns the area of a cylinder with radius =r= and height =h=.
#+end_quote

#+begin_quote
#+begin_example
area_of_cone(r: float|int, h: float|int) -> float|int
#+end_example

Returns the area of a cone with radius =r= and height =h=.
#+end_quote

*** *Class List*: /None/

** List

*** *Import*: ="std/list.earl"=

*** *Module*: =List=

*** *Variable List*:
#+begin_quote
#+begin_example
DEFAULT_INT_ASCEND_QUICKSORT: closure(int, int) -> bool
#+end_example

The default comparison function for ascending sort.
#+end_quote

#+begin_quote
#+begin_example
DEFAULT_INT_DESCEND_QUICKSORT: closure(int, int) -> bool
#+end_example

The default comparison function for descending sort.
#+end_quote

*** *Enum List*: /None/

*** *Function List*:
#+begin_quote
#+begin_example
preset(elem: any, cap: int) -> str
#+end_example

Creates a list with elements =elem= of size =cap=.
#+end_quote

#+begin_quote
#+begin_example
from_range(start: int, stop: int, stride: int) -> list<int|float>
#+end_example

Takes a list and then returns element within range specified by the parameters =start=, =stop=, =stride=.
#+end_quote

#+begin_quote
#+begin_example
fill(lst: @ref list<any>, : : any) -> unit
#+end_example

Fills the given list =lst= with element =k=.
#+end_quote

#+begin_quote
#+begin_example
sumf(lst: @const @ref list<float|int>) -> float
#+end_example

Returns the sum all elements in =lst= as a float.
#+end_quote

#+begin_quote
#+begin_example
sum(lst: @const @ref list<int|float>) -> int
#+end_example

Returns the sum all elements in =lst= as an integer.
#+end_quote

#+begin_quote
#+begin_example
find(lst: @const @ref list<any>, elem: @const @ref any) -> option<int>
#+end_example

Takes a reference to a list and a reference to an element and looks for the element find in the given list Returns the index of the first occurrence that =elem= appears in =lst= wrapped in =some=, or =none= if not found.
#+end_quote

#+begin_quote
#+begin_example
count(lst: @const @ref list<any>, elem: @const @ref any) -> int
#+end_example

Counts the number of occurrences that =elem= appears in =lst=.
#+end_quote

#+begin_quote
#+begin_example
quicksort(lst: @ref list<any>, compar: @const closure(x1: any, x2: type(x1)) -> bool|int) -> unit
#+end_example

where =compar= is some ordering function $F(x_1, x_2) \in \{true, false\}$  and $F$ is defined by  \[ F(x_1, x_2) = \begin{cases} true & \text{if } R(x_1) \ge R(x_2) \\ false & \text{if } R(x_1) < R(x_2) \end{cases} \]  and $R(x)$ is some ranking function that produces a rank of $x$.  Performs the quicksort sorting algorithm on =lst= and sorts by the comparison closure =compar=.
#+end_quote

*** *Class List*: /None/

** Utils

*** *Import*: ="std/utils.earl"=

*** *Module*: =Utils=

*** *Variable List*: /None/

*** *Enum List*: /None/

*** *Function List*:
#+begin_quote
#+begin_example
is_even(n: int) -> bool
#+end_example

Returns =true= if =n= is even, or =false= if otherwise.
#+end_quote

#+begin_quote
#+begin_example
swap(x1: @ref any, x2: @ref type(x1)) -> unit
#+end_example

Swap =x1= and =x2= in-place.
#+end_quote

#+begin_quote
#+begin_example
iota() -> int
#+end_example

Returns 0 on first call, then 0+1 on second, then 0+1+1 on third etc.
#+end_quote

*** *Class List*: /None/

** Queue

*** *Import*: ="std/queue.earl"=

*** *Module*: =Queue=

*** *Variable List*: /None/

*** *Enum List*: /None/

*** *Function List*: /None/

*** *Class List*:
*** *=T=*
#+begin_quote
#+begin_example
T [init: list]
#+end_example
Provides a class for the =queue= data structure.
#+end_quote

**** *=T= Implements*

#+begin_quote
#+begin_example
empty() -> bool
#+end_example

Returns =true= if the =queue= is empty, or =false= if otherwise. 

#+end_quote
#+begin_quote
#+begin_example
enqueue(value: any) -> unit
#+end_example

Inserts =value= into the =queue=. 

#+end_quote
#+begin_quote
#+begin_example
dequeue() -> unit
#+end_example

Pops the element in the font of the =queue=. 

#+end_quote
#+begin_quote
#+begin_example
peek() -> any
#+end_example

Returns the element in the font of the =queue=. 

#+end_quote
#+begin_quote
#+begin_example
size() -> int
#+end_example

Returns the size of the =queue=. 

#+end_quote

** SinglyLL

*** *Import*: ="std/linked-list.earl"=

*** *Module*: =SinglyLL=

*** *Variable List*: /None/

*** *Enum List*: /None/

*** *Function List*: /None/

*** *Class List*:
*** *=T=*
#+begin_quote
#+begin_example
T [init: list]
#+end_example
Takes the initializer list =init= and creates a linked list of the elements if they exist.
#+end_quote

**** *=T= Implements*

#+begin_quote
#+begin_example
insert(value: any) -> unit
#+end_example

Inserts =value= into the list. 

#+end_quote
#+begin_quote
#+begin_example
contains(value: any) -> bool
#+end_example

Checks to see if =value= is in the list. Returns =true= if so, else =false=. 

#+end_quote
#+begin_quote
#+begin_example
show() -> unit
#+end_example

Prints all elements in the list to =stdout=. 

#+end_quote

** Encryption

*** *Import*: ="std/encryption.earl"=

*** *Module*: =Encryption=

*** *Variable List*: /None/

*** *Enum List*: /None/

*** *Function List*:
#+begin_quote
#+begin_example
rle(src: str) -> str
#+end_example

Performs Run Length Encoding on =src=.
#+end_quote

*** *Class List*: /None/

** IO

*** *Import*: ="std/io.earl"=

*** *Module*: =IO=

*** *Variable List*: /None/

*** *Enum List*:
#+begin_quote
#+begin_example
Fd {
    In -> int,
    Out -> int,
    Err -> int
}
#+end_example

The integer codes for =stdin=, =stdout=, and =stderr= for =In=, =Out=, and =Err= respectively.
#+end_quote

*** *Function List*:
#+begin_quote
#+begin_example
file_to_str(fp: str) -> str
#+end_example

Get the contents of a file =fp= and put it into a string.
#+end_quote

#+begin_quote
#+begin_example
read_lines(fp: str) -> list
#+end_example

Read the lines of the file =fp= and get each line as a list.
#+end_quote

#+begin_quote
#+begin_example
rename(path_from: str, path_to: str) -> unit
#+end_example

Rename the file =path_from= to =path_to=.
#+end_quote

*** *Class List*: /None/

** Str

*** *Import*: ="std/str.earl"=

*** *Module*: =Str=

*** *Variable List*: /None/

*** *Enum List*: /None/

*** *Function List*:
#+begin_quote
#+begin_example
to_list(s: @ref str) -> list
#+end_example

Convert the string =s= to a =list=.
#+end_quote

#+begin_quote
#+begin_example
find(s: @ref str, t: char) -> int
#+end_example

Returns the index of target =t= in a =some= value or =none= if not found.
#+end_quote

#+begin_quote
#+begin_example
trim(s: @ref str) -> unit
#+end_example

Trims all whitespace (spaces, tabs, newlines etc.) from =s= in-place.
#+end_quote

*** *Class List*: /None/

** CSV

*** *Import*: ="std/csv.earl"=

*** *Module*: =CSV=

*** *Variable List*: /None/

*** *Enum List*: /None/

*** *Function List*:
#+begin_quote
#+begin_example
parse(src: str) -> list
#+end_example

Takes src file path of csv file and parses it
#+end_quote

*** *Class List*: /None/

** Char

*** *Import*: ="std/char.earl"=

*** *Module*: =Char=

*** *Variable List*: /None/

*** *Enum List*: /None/

*** *Function List*:
#+begin_quote
#+begin_example
isalpha(c: char) -> bool
#+end_example

Takes the char =c= and returns a boolean of whether or not it is a an alpha character.
#+end_quote

#+begin_quote
#+begin_example
isnum(c: char) -> bool
#+end_example

Takes the char =c= and returns a boolean of whether or not it is a digit.
#+end_quote

#+begin_quote
#+begin_example
isalnum(c: char) -> bool
#+end_example

Takes the char =c= and returns a boolean of whether or not it is a digit or an alpha character.
#+end_quote

#+begin_quote
#+begin_example
tolower(c: char) -> char
#+end_example

Takes the char =c= and returns a lowercase character version of the latin alphabet
#+end_quote

#+begin_quote
#+begin_example
toupper(c: char) -> char
#+end_example

Takes the char =c= and returns a uppercase character version of the latin alphabet
#+end_quote

*** *Class List*: /None/

** Set

*** *Import*: ="std/set.earl"=

*** *Module*: =Set=

*** *Variable List*: /None/

*** *Enum List*: /None/

*** *Function List*: /None/

*** *Class List*:
*** *=T=*
#+begin_quote
#+begin_example
T [init: list<x0: any, x1: type(x0), ..., xN: type(x0)>]
#+end_example
Creates a new Set container with the initializer list =init=.
#+end_quote

**** *=T= Implements*

#+begin_quote
#+begin_example
insert(value: any) -> unit
#+end_example

Insert =value= into the =set=. A panic will occur if the =typeof(value)= is not the same as the other values in the =set=. 

#+end_quote
#+begin_quote
#+begin_example
contains(value: any) -> bool
#+end_example

Returns =true= if =value= is in the =set=, or =false= if it is not. A panic will occur if the =typeof(value)= is not the same as the other values in the =set=. 

#+end_quote

** Stack

*** *Import*: ="std/stack.earl"=

*** *Module*: =Stack=

*** *Variable List*: /None/

*** *Enum List*: /None/

*** *Function List*: /None/

*** *Class List*:
*** *=T=*
#+begin_quote
#+begin_example
T [init: list]
#+end_example
Create a stack based off of the initializer list =init= if it contains any elements.
#+end_quote

**** *=T= Implements*

#+begin_quote
#+begin_example
push(x: any) -> unit
#+end_example

Pushes =x= onto the =stack=. 

#+end_quote
#+begin_quote
#+begin_example
pop() -> unit
#+end_example

Pops last element on the =stack=. 

#+end_quote
#+begin_quote
#+begin_example
empty() -> bool
#+end_example

Return =true= if the =stack= is empty or =false= if otherwise. 

#+end_quote
#+begin_quote
#+begin_example
top() -> any
#+end_example

Returns the element at the top of the =stack=. 

#+end_quote
#+begin_quote
#+begin_example
show() -> unit
#+end_example

Prints the entire =stack=. 

#+end_quote

** System

*** *Import*: ="std/system.earl"=

*** *Module*: =System=

*** *Variable List*: /None/

*** *Enum List*: /None/

*** *Function List*:
#+begin_quote
#+begin_example
ls(path: str) -> list
#+end_example

List all items at the path =path= and return a list of all elements it contains.
#+end_quote

#+begin_quote
#+begin_example
mkdir(name: str) -> unit
#+end_example

Create a new directory in the =cwd= called =name=.
#+end_quote

#+begin_quote
#+begin_example
fullpath_mkdir(fullpath: str) -> unit
#+end_example

Creates a full path directory as well as a file i.e., ./dir1/dir2/dir3/file.txt. The last entry in the path will be used as the file to be created. It is functionally equivalent to: =mkdir -p <path> && touch <path>/file.txt=.
#+end_quote

#+begin_quote
#+begin_example
name_and_ext(filepath: str) -> tuple
#+end_example

Returns a tuple of filename and extension. If either the name or extension cannot be found, the respective one will be set to =none=.
#+end_quote

#+begin_quote
#+begin_example
move(path_from: str, path_to: str) -> unit
#+end_example

Move the file =path_from= to =path_to=.
#+end_quote

*** *Class List*: /None/

** BasicLexer

*** *Import*: ="std/basic-lexer.earl"=

*** *Module*: =BasicLexer=

*** *Variable List*: /None/

*** *Enum List*:
#+begin_quote
#+begin_example
TokenType {
    Ident -> int,
    StrLit -> int,
    IntLit -> int,
    CharLit -> int,
    Hash -> int,
    LParen -> int,
    RParen -> int,
    LCurly -> int,
    RCurly -> int,
    LBracket -> int,
    RBracket -> int,
    Plus -> int,
    Minus -> int,
    Asterisk -> int,
    ForwardSlash -> int,
    Equals -> int,
    Comma -> int,
    Greaterthan -> int,
    Lessthan -> int,
    Colon -> int,
    At -> int,
    Period -> int,
    Semicolon -> int,
    Backtick -> int,
    Underscore -> int,
    Pipe -> int,
    Ampersand -> int,
    Hash -> int,
    Percent -> int,
    Caret -> int,
    DollarSign -> int,
    Tilde -> int,
    Keyword -> int
}
#+end_example

Individual identifiers for each token type.
#+end_quote

*** *Function List*: /None/

*** *Class List*:
*** *=Token=*
#+begin_quote
#+begin_example
Token [lx: str, ty: TokenType, r: int, c: int, fp: str]
#+end_example
A token class that constists of: =lx= -> lexeme, =ty= -> token type, =r=  -> row, =c=  -> column, =fp= -> filepath The =lexeme= of the token. The type of the token. The row that the token is located at. The column that the token is located at. The filepath that the token is located at.
#+end_quote
**** *=Token= Members*:

#+begin_quote
#+begin_example
lx: str
#+end_example

The =lexeme= of the token. 

#+end_quote
#+begin_quote
#+begin_example
ty: TokenType
#+end_example

The type of the token. 

#+end_quote
#+begin_quote
#+begin_example
r: int
#+end_example

The row that the token is located at. 

#+end_quote
#+begin_quote
#+begin_example
c: int
#+end_example

The column that the token is located at. 

#+end_quote
#+begin_quote
#+begin_example
fp: int
#+end_example

The filepath that the token is located at. 

#+end_quote

*** *=T=*
#+begin_quote
#+begin_example
T [keywords: tuple<str>|list<str>]
#+end_example
Creates a new Basic Lexer class with the keywords set to =keywords=. The list of tokens that the lexer currently holds. The default operators and symbols.
#+end_quote
**** *=T= Members*:

#+begin_quote
#+begin_example
tokens: list<Token>
#+end_example

The list of tokens that the lexer currently holds. 

#+end_quote
#+begin_quote
#+begin_example
default_ops: Dict<str>
#+end_example

The default operators and symbols. 

#+end_quote

**** *=T= Implements*

#+begin_quote
#+begin_example
lex(src: str, fp: str) -> unit
#+end_example

Performs basic lexical analysis on the source code =src= at the filepath =fp=. 

#+end_quote
#+begin_quote
#+begin_example
next() -> option<Token>
#+end_example

Returns =some(token)= if the lexer is not empty and pops it from the lexer, or =none= if no tokens exist. 

#+end_quote
#+begin_quote
#+begin_example
peek(pk: int) -> option<Token>
#+end_example

Returns the token at location =pk= wrapped in =some= or =none= if not found. 

#+end_quote
#+begin_quote
#+begin_example
sz() -> int
#+end_example

Return the number of tokens the lexer currently holds. 

#+end_quote

