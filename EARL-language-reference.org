# BEGIN_AUTOGEN
** IO

*** *Import*: ="../src/std/io.earl"=

*** *Module*: =IO=

*** *Variable List*: /None/

*** *Enum List*:
#+begin_quote
#+begin_example
Fd {
    In -> int,
    Out -> int,
    Err -> int
}
#+end_example

The integer codes for =stdin=, =stdout=, and =stderr= for
=In=, =Out=, and =Err= respectively.
#+end_quote

*** *Function List*:
#+begin_quote
#+begin_example
file_to_str(fp: str) -> str
#+end_example

Get the contents of a file =fp= and put it into a string.
#+end_quote

#+begin_quote
#+begin_example
read_lines(fp: str) -> list
#+end_example

Read the lines of the file =fp= and get
each line as a list.
#+end_quote

#+begin_quote
#+begin_example
write_to_file(content: str, fp: str) -> unit
#+end_example

Takes the string =content= and writes it to
the file =fp=.
#+end_quote

#+begin_quote
#+begin_example
rename(path_from: str, path_to: str) -> unit
#+end_example

Rename the file =path_from= to =path_to=.
#+end_quote

*** *Class List*: /None/

** Encryption

*** *Import*: ="../src/std/encryption.earl"=

*** *Module*: =Encryption=

*** *Variable List*: /None/

*** *Enum List*: /None/

*** *Function List*:
#+begin_quote
#+begin_example
rle(src: str) -> str
#+end_example

Performs Run Length Encoding on =src=.
#+end_quote

*** *Class List*: /None/

** Script

*** *Import*: ="../src/std/script.earl"=

*** *Module*: =Script=

*** *Variable List*: /None/

*** *Enum List*: /None/

*** *Function List*:
#+begin_quote
#+begin_example
program_exists(progname: str) -> str
#+end_example

Returns =true= if =progname= exists as a program on the
machine or =false= if otherwise.
#+end_quote

#+begin_quote
#+begin_example
get_pid(proc: str) -> list<tuple<int, str>>
#+end_example

Returns a list of pids and the process associated
with it in the form of =[(pid1, proc1), (pid2, proc2), ..., (pidN, procN)]=.
#+end_quote

#+begin_quote
#+begin_example
kill_pid(pid: int) -> unit
#+end_example

Kill the PID =pid=.
#+end_quote

#+begin_quote
#+begin_example
kill_pids(pid: list<int>) -> unit
#+end_example

Kill all PIDs =pids=.
#+end_quote

#+begin_quote
#+begin_example
wget(link: str, name: str) -> unit
#+end_example

Performs a =wget= on =link= and saves it to =name=.
#+end_quote

#+begin_quote
#+begin_example
wget_wredirects(link: str, name: str) -> unit
#+end_example

Performs a =wget= on =link= and saves it to =name=.
Allows redirects.
#+end_quote

#+begin_quote
#+begin_example
git_clone(link: str, depth: int) -> unit
#+end_example

Performs a =git clone <link> --depth=<depth>=. To not
specify a depth, put some number less than 1 as the =depth=.
#+end_quote

#+begin_quote
#+begin_example
whoami() -> str
#+end_example

Return the user as a =str=.
#+end_quote

#+begin_quote
#+begin_example
all_running_procs() -> list<dict<str>>
#+end_example

Return information on all running processes as a =dict<str>=
in the form of:
=dict["user"] = str=
=dict["pid"] = str=
=dict["cpu"] = str=
=dict["mem"] = str=
=dict["vsz"] = str=
=dict["rss"] = str=
=dict["tty"] = str=
=dict["stat"] = str=
=dict["start"] = str=
=dict["time"] = str=
=dict["cmd"] = str=
#+end_quote

#+begin_quote
#+begin_example
launch_proc(proc: str) -> unit
#+end_example

Launch the processes =proc=.
#+end_quote

#+begin_quote
#+begin_example
launch_bgproc(proc: str) -> unit
#+end_example

Launch the processes =proc= in the background.
#+end_quote

*** *Class List*: /None/

** List

*** *Import*: ="../src/std/list.earl"=

*** *Module*: =List=

*** *Variable List*:
#+begin_quote
#+begin_example
DEFAULT_INT_ASCEND_QUICKSORT: closure(int, int) -> bool
#+end_example

The default comparison function for ascending sort.
#+end_quote

#+begin_quote
#+begin_example
DEFAULT_INT_DESCEND_QUICKSORT: closure(int, int) -> bool
#+end_example

The default comparison function for descending sort.
#+end_quote

*** *Enum List*: /None/

*** *Function List*:
#+begin_quote
#+begin_example
preset(elem: any, cap: int) -> list
#+end_example

Creates a list with elements =elem= of size =cap=.
#+end_quote

#+begin_quote
#+begin_example
from_range(start: int, stop: int, stride: int) -> list<int|float>
#+end_example

Takes a list and then returns element within range specified by the parameters =start=, =stop=, =stride=.
#+end_quote

#+begin_quote
#+begin_example
fill(lst: @ref list<any>, k: any) -> unit
#+end_example

Fills the given list =lst= with element =k=.
#+end_quote

#+begin_quote
#+begin_example
sumf(lst: @const @ref list<real>) -> float
#+end_example

Returns the sum all elements in =lst= as a float.
#+end_quote

#+begin_quote
#+begin_example
sum(lst: @const @ref list<int|float>) -> int
#+end_example

Returns the sum all elements in =lst= as an integer.
#+end_quote

#+begin_quote
#+begin_example
find(lst: @const @ref list<any>, elem: @const @ref any) -> option<int>
#+end_example

Takes a reference to a list and a reference to an element and looks for the element find in the given list
Returns the index of the first occurrence that =elem= appears in =lst= wrapped in =some=, or =none= if not found.
#+end_quote

#+begin_quote
#+begin_example
count(lst: @const @ref list<any>, elem: @const @ref any) -> int
#+end_example

Counts the number of occurrences that =elem= appears in =lst=.
#+end_quote

#+begin_quote
#+begin_example
quicksort(lst: @ref list<any>, compar: : @const closure(x1: any, x2: type(x1)) -> bool|int) -> unit
#+end_example

where =compar= is some ordering function $F(x_1, x_2) \in \{true, false\}$
and $F$ is defined by
\[
F(x_1, x_2) = \begin{cases}
true & \text{if } R(x_1) \ge R(x_2) \\
false & \text{if } R(x_1) < R(x_2)
\end{cases}
\]
and $R(x)$ is some ranking function that produces a rank of $x$.
Performs the quicksort sorting algorithm on =lst= and
sorts by the comparison closure =compar=.
#+end_quote

#+begin_quote
#+begin_example
dict_to_list(dict: @const @ref dict<any, any>) -> list<tuple<any, any>>
#+end_example

Converts the dictionary =dict= to a list.
#+end_quote

*** *Class List*: /None/

** Matrix

*** *Import*: ="../src/std/matrix.earl"=

*** *Module*: =Matrix=

*** *Variable List*: /None/

*** *Enum List*: /None/

*** *Function List*:
#+begin_quote
#+begin_example
identity() -> T
#+end_example

Creates the identity matrix.
#+end_quote

#+begin_quote
#+begin_example
from1d(data: list<any>, rows: int, cols: int) -> T
#+end_example

Creates a =rows= x =cols= matrix from a 1d list.
#+end_quote

#+begin_quote
#+begin_example
from2d(data: list<list<any>>) -> T
#+end_example

Creates a matrix from a 2d list.
#+end_quote

*** *Class List*:
*** *=T=*
#+begin_quote
#+begin_example
T [init: list<any>, rows: int, cols: int]
#+end_example
Creates a new matrix with the initial dataset =init=
with =rows= rows and =cols= columns.
#+end_quote

**** *=T= Implements*

#+begin_quote
#+begin_example
at(i: int, j: int) -> any
#+end_example

Returns the element at [ =i= ][ =j= ] in the matrix.

#+end_quote
#+begin_quote
#+begin_example
show() -> unit
#+end_example

Prints all elements in the matrix.

#+end_quote

** Char

*** *Import*: ="../src/std/char.earl"=

*** *Module*: =Char=

*** *Variable List*: /None/

*** *Enum List*: /None/

*** *Function List*:
#+begin_quote
#+begin_example
isalpha(c: char) -> bool
#+end_example

Takes the char =c= and returns a boolean of whether or not it is a an alpha character.
#+end_quote

#+begin_quote
#+begin_example
isnum(c: char) -> bool
#+end_example

Takes the char =c= and returns a boolean of whether or not
it is a digit.
#+end_quote

#+begin_quote
#+begin_example
isalnum(c: char) -> bool
#+end_example

Takes the char =c= and returns a boolean of whether or not it is a digit or an alpha character.
#+end_quote

#+begin_quote
#+begin_example
tolower(c: char) -> char
#+end_example

Takes the char =c= and returns a lowercase character version of the latin alphabet
#+end_quote

#+begin_quote
#+begin_example
toupper(c: char) -> char
#+end_example

Takes the char =c= and returns a uppercase character version of the latin alphabet
#+end_quote

*** *Class List*: /None/

** Str

*** *Import*: ="../src/std/str.earl"=

*** *Module*: =Str=

*** *Variable List*: /None/

*** *Enum List*: /None/

*** *Function List*:
#+begin_quote
#+begin_example
to_list(s: @ref str) -> list
#+end_example

Convert the string =s= to a =list=.
#+end_quote

#+begin_quote
#+begin_example
find(s: @ref str, t: char) -> int
#+end_example

Returns the index of target =t= in a =some= value or =none= if not found.
#+end_quote

#+begin_quote
#+begin_example
trim(s: @ref str) -> unit
#+end_example

Trims all whitespace (spaces, tabs, newlines etc.) from =s= in-place.
#+end_quote

#+begin_quote
#+begin_example
find_first_of(s: @const @ref str, t: char) -> option<int>
#+end_example

Finds the first ocurrence of =t= in =s=.
#+end_quote

#+begin_quote
#+begin_example
find_last_of(s: @const @ref str, t: char) -> option<int>
#+end_example

Finds the last ocurrence of =t= in =s=.
#+end_quote

*** *Class List*: /None/

** Set

*** *Import*: ="../src/std/set.earl"=

*** *Module*: =Set=

*** *Variable List*: /None/

*** *Enum List*: /None/

*** *Function List*: /None/

*** *Class List*:
*** *=T=*
#+begin_quote
#+begin_example
T [init: : list<x0: any, x1: type(x0), ..., xN: type(x0)>]
#+end_example
Creates a new Set container with the initializer list =init=.
#+end_quote

**** *=T= Implements*

#+begin_quote
#+begin_example
insert(value: any) -> unit
#+end_example

Insert =value= into the =set=. A panic will occur
if the =typeof(value)= is not the same as the other
values in the =set=.

#+end_quote
#+begin_quote
#+begin_example
contains(value: any) -> bool
#+end_example

Returns =true= if =value= is in the =set=, or =false= if it is not.
A panic will occur if the =typeof(value)= is not the same as the other
values in the =set=.

#+end_quote

** Utils

*** *Import*: ="../src/std/utils.earl"=

*** *Module*: =Utils=

*** *Variable List*: /None/

*** *Enum List*: /None/

*** *Function List*:
#+begin_quote
#+begin_example
is_even(n: int) -> bool
#+end_example

Returns =true= if =n= is even, or =false= if otherwise.
#+end_quote

#+begin_quote
#+begin_example
is_odd(n: int) -> bool
#+end_example

Returns =true= if =n= is odd, or =false= if otherwise.
#+end_quote

#+begin_quote
#+begin_example
swap(x1: @ref any, x2: @ref type(x1)) -> unit
#+end_example

Swap =x1= and =x2= in-place.
#+end_quote

#+begin_quote
#+begin_example
iota() -> int
#+end_example

Returns 0 on first call, then 0+1 on second, then 0+1+1 on third etc.
#+end_quote

*** *Class List*: /None/

** System

*** *Import*: ="../src/std/system.earl"=

*** *Module*: =System=

*** *Variable List*: /None/

*** *Enum List*: /None/

*** *Function List*:
#+begin_quote
#+begin_example
ls(path: str) -> list
#+end_example

List all items at the path =path= and return a list of
all elements it contains.
#+end_quote

#+begin_quote
#+begin_example
cd(path: str) -> unit
#+end_example

Change the current working directory to =path=.
#+end_quote

#+begin_quote
#+begin_example
mkdir(name: str) -> unit
#+end_example

Create a new directory in the =cwd= called =name=.
#+end_quote

#+begin_quote
#+begin_example
fullpath_mkdir(fullpath: str) -> unit
#+end_example

Creates a full path directory as well as a file
i.e., ./dir1/dir2/dir3/file.txt. The last entry
in the path will be used as the file to be created.
It is functionally equivalent to: =mkdir -p <path> && touch <path>/file.txt=.
#+end_quote

#+begin_quote
#+begin_example
name_and_ext(filepath: str) -> tuple
#+end_example

Returns a tuple of filename and extension. If either the name or extension
cannot be found, the respective one will be set to =none=.
#+end_quote

#+begin_quote
#+begin_example
move(path_from: str, path_to: str) -> unit
#+end_example

Move the file =path_from= to =path_to=.
#+end_quote

#+begin_quote
#+begin_example
cmd(cmd: str) -> int
#+end_example

Run the bash command =cmd=. Returns the exit code.
#+end_quote

#+begin_quote
#+begin_example
cmd_wcheck(cmd: str) -> unit
#+end_example

Run the bash command =cmd= and checks the exit code.
Will print a warning if the exit code is not zero.
#+end_quote

#+begin_quote
#+begin_example
cmd_onfail(cmd: str, onfail: closure) -> unit
#+end_example

Run the bash command =cmd= and checks the exit code.
Will run =onfail= if the exit code is not 0.
#+end_quote

#+begin_quote
#+begin_example
cmdstr(cmd: str) -> str
#+end_example

Run the bash command =cmd= and return the
output as a =str=.
#+end_quote

#+begin_quote
#+begin_example
cmdstr_wexitcode(cmd: str) -> tuple<int, str>
#+end_example

Run the bash command =cmd= and return the
output as a tuple of =(exit_code, output)=.
#+end_quote

*** *Class List*: /None/

** Assert

*** *Import*: ="../src/std/assert.earl"=

*** *Module*: =Assert=

*** *Variable List*:
#+begin_quote
#+begin_example
CRASH_ON_FAILURE: bool
#+end_example

Will crash the program on assertion failures
if set to =true=. Otherwise will print failures
to =stderr=. By default, it is set to =true=.
#+end_quote

#+begin_quote
#+begin_example
FILE: str
#+end_example

Should be set in the caller file to set the file location
that the assertions are being called from using =__FILE__=.
*Note*: This variable must be set manually.
#+end_quote

#+begin_quote
#+begin_example
FUNC: str
#+end_example

Should be set in the caller file in the function
that the assertions are being called from using =__FUNC__=.
*Note*: This variable must be set manually.
#+end_quote

*** *Enum List*: /None/

*** *Function List*:
#+begin_quote
#+begin_example
is_true(cond: bool) -> unit
#+end_example

Tests =cond= for =true=.
#+end_quote

#+begin_quote
#+begin_example
is_false(cond: bool) -> unit
#+end_example

Tests =cond= for =false=.
#+end_quote

#+begin_quote
#+begin_example
eq(l: any, r: any) -> unit
#+end_example

Tests for =l= equal to =r=. *Note*: this function
is type safe to it will not panic with differing types.
#+end_quote

#+begin_quote
#+begin_example
neq(l: any, r: any) -> unit
#+end_example

Tests for =l= not equal to =r=. *Note*: this function
is type safe to it will not panic with differing types.
#+end_quote

#+begin_quote
#+begin_example
not_none(k: any) -> unit
#+end_example

Tests for =k= being not =none=. *Note*: this function
is type safe so it will not panic with differing types.
#+end_quote

#+begin_quote
#+begin_example
is_none(k: any) -> unit
#+end_example

Tests for =k= being =none=. *Note*: this function
is type safe so it will not panic with differing types.
#+end_quote

*** *Class List*: /None/

** Math

*** *Import*: ="../src/std/math.earl"=

*** *Module*: =Math=

*** *Variable List*:
#+begin_quote
#+begin_example
PI: float
#+end_example

The mathematical constant for pi.
#+end_quote

#+begin_quote
#+begin_example
EULER: float
#+end_example

The mathematical constant for Euler's number.
#+end_quote

*** *Enum List*: /None/

*** *Function List*:
#+begin_quote
#+begin_example
max(x: real, y: real) -> real
#+end_example

Returns the greater of =x= and =y=.
#+end_quote

#+begin_quote
#+begin_example
min(x: real, y: real) -> real
#+end_example

Returns the minimum of =x= and =y=.
#+end_quote

#+begin_quote
#+begin_example
abs(x: real) -> real
#+end_example

Returns the absolute value of =x=.
#+end_quote

#+begin_quote
#+begin_example
mode(lst: list) -> list
#+end_example

This function returns a list of all modes that appear at the
highest frequency in the given list in the order modes are found.
#+end_quote

#+begin_quote
#+begin_example
mean(lst: list) -> float
#+end_example

Returns the mean (average in a dataset) of a given list.
#+end_quote

#+begin_quote
#+begin_example
median(lst: list) -> int
#+end_example

This function sorts and then returns the middle number of a given list
#+end_quote

#+begin_quote
#+begin_example
list_min(lst: list) -> real
#+end_example

Returns the smallest element =lst=.
#+end_quote

#+begin_quote
#+begin_example
list_max(lst: list) -> real
#+end_example

Returns the largest element =lst=.
#+end_quote

#+begin_quote
#+begin_example
area_of_circle(r: real) -> real
#+end_example

Returns the area of a circle with radius =r=.
#+end_quote

#+begin_quote
#+begin_example
volume_of_cylinder(r: real, h: real) -> real
#+end_example

Returns the volume of a cylinder with radius =r= and height =h=.
#+end_quote

#+begin_quote
#+begin_example
volume_of_cone(r: real, h: real) -> real
#+end_example

Returns the volume of a cone with radius =r= and height =h=.
#+end_quote

#+begin_quote
#+begin_example
floor(f: float) -> int
#+end_example

Returns the floor of =f=.
#+end_quote

#+begin_quote
#+begin_example
ceil(f: float) -> int
#+end_example

Returns the ceil of =f=.
#+end_quote

#+begin_quote
#+begin_example
lerp(a: real, b: real, f: real) -> real
#+end_example

Performs the lerp algorithm from =a= to =b= by =f=.
#+end_quote

#+begin_quote
#+begin_example
normalize(x: real, min: float, max: float) -> float
#+end_example

Normalizes =x= to the range of =min= .. =max=.
#+end_quote

#+begin_quote
#+begin_example
clamp(value: real, min: real, max: real) -> real
#+end_example

Performs clamp on =value= with =min= and =max=.
#+end_quote

*** *Class List*: /None/

