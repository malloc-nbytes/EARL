module TestMgr

import "std/system.rl";
import "std/io.rl";
import "std/str.rl";

#--- This file will either generate the test entrypoint
#--- or it can be used to generate a test template.

fn _help() {
    println("Usage");
    println("    new <filename> <modname>", "  Creates a new test template");
    println("    gen <print> <crash>", "       Generate the test entrypoint");
    println("Note");
    println("    The parser is very primitive and not human-friendly so it is");
    println("    encouraged to use the `new` option when creating a new test file.");
    exit(0);
}

fn gen(should_print, crash_on_failure) {
    println("--- GENERATING TEST ENTRYPOINT ---");

    let main_test_filepath = "./test.rl";
    let function_splitter_id = "ENTRYPOINT";

    let main_test_module = "Test";
    let main_test_fun = "main";
    let src = f"module {main_test_module}\n\n# THIS FILE IS AUTOGENERATED\n\n";

    let blacklisted_files = (
        __FILE__,
        "./imports",
        "./testmgr.rl",
        "./test.rl",
        "./test-utils.rl",
        "./other-files",
        "./cmds.txt",
        "./runner.sh",
    );

    println(f"Blacklisted files: {blacklisted_files}");

    let tests = System::ls(".").filter(|s| {
        foreach file in blacklisted_files {
            if s == file {
                println("FILTERED: ", s);
                return false;
            }
        }
        return true;
    });

    println("TESTS: ", tests);

    foreach test in tests {
        src += f"import \"{test}\";\n";
    }

    src += "\nfn "+ main_test_fun +"() {\n";
    src += "    let should_print = " + str(should_print) + ";\n";
    src += "    let crash_on_failure = " + str(crash_on_failure) + ";\n";

    foreach test in tests {
        println(f"Gathered test file: {test}");
        let test_code = IO::file_to_str(test);
        let mod = test_code
            .split("\n")[0]
            .split(" ")[1];

        let entry = test_code
            .split(function_splitter_id)[1]
            .split("\n")
            .map(|s| {
                Str::trim(s);
                return s;
            })
            .filter(|s| {return len(s) > 3 && s.substr(0, 2) == "fn";})[0];

        let fun = entry.substr(3, len(entry));
        while fun.back() != ')' {
            fun.pop(len(fun)-1);
        }
        src += "    " + mod + "::" + fun + ";\n";
    }

    src += "}\n\n" + f"{main_test_fun}();";

    let f = open(main_test_filepath, "w");
    f.write(src);
    f.close();

    println("--- GENERATED TEST ENTRYPOINT ---");
    println(src);
}

fn create_test_file(filename, modname) {
    let s = f"module {modname}\n\n";

    s += "import \"std/assert.rl\";\n";
    s += "import \"test-utils.rl\";\n\n";

    s += "Assert::FILE = __FILE__;\n\n";

    s += "fn my_test(out) {\n";
    s += "    TestUtils::log(out, __FILE__, __FUNC__, Assert::FUNC);\n";
    s += "}\n\n";

    s += "# ENTRYPOINT\n";
    s += "@pub @world\n";
    s += "fn run(should_print, crash_on_failure) {\n";
    s += "    let out = should_print;\n";
    s += "    Assert::CRASH_ON_FAILURE = crash_on_failure;\n\n";
    s += "    my_test(out);\n";
    s += "}";

    let f = open(filename, "w");
    f.write(s);
    f.close();
}

fn handleargs(args) {
    let get_gen_args = |lst| {
        if len(lst) < 3 {
            panic("not enough arguments for `gen`");
        }
        return (lst[1], lst[2]);
    };

    let get_name_args = |lst| {
        if len(lst) < 3 {
            panic("not enough arguments for `new`");
        }
        return (lst[1], lst[2]);
    };

    args.pop(0);

    for i in 0 to len(args) {
        match args[i] {
            "new" -> {
                let filename, modname = get_name_args(args[i:]);
                create_test_file(filename, modname);
                i += 2;
            }
            "gen" -> {
                let sp, crash = get_gen_args(args[i:]);
                i += 2;
                gen(sp, crash);
            }
            _ -> { panic("unknown argument: ", args[i]); }
        }
    }
}

let args = argv();

if len(args) < 2 {
    _help();
}

handleargs(args);

